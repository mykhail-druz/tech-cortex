/**
 * Smart Specification System
 *
 * This class provides intelligent category type detection, automatic profile suggestion,
 * and specification validation using semantic tags. It works alongside the existing
 * CategorySpecificationTemplate system to provide enhanced functionality.
 */

import { supabase } from '@/lib/supabaseClient';
import {
  SemanticTag,
  ComponentProfile,
  StandardSpecification,
  SpecificationDetectionResult,
  AutoDetectionRule,
  TagCompatibilityRule,
} from '@/lib/supabase/types/semanticTags';
import {
  SpecificationValidator,
  SpecificationValidationResult,
} from '@/lib/supabase/types/specifications';
import {
  COMPONENT_PROFILES,
  AUTO_DETECTION_RULES,
  TAG_COMPATIBILITY_RULES,
} from './componentProfiles';

export class SmartSpecificationSystem {
  private static instance: SmartSpecificationSystem;
  private profiles: ComponentProfile[] = [];
  private autoDetectionRules: AutoDetectionRule[] = [];
  private tagCompatibilityRules: TagCompatibilityRule[] = [];
  private initialized = false;

  private constructor() {}

  public static getInstance(): SmartSpecificationSystem {
    if (!SmartSpecificationSystem.instance) {
      SmartSpecificationSystem.instance = new SmartSpecificationSystem();
    }
    return SmartSpecificationSystem.instance;
  }

  /**
   * Initialize the system by loading profiles and rules from database
   */
  public async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      await this.loadProfilesFromDatabase();
      await this.loadAutoDetectionRules();
      await this.loadTagCompatibilityRules();
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize SmartSpecificationSystem:', error);
      // Fallback to hardcoded profiles
      this.profiles = COMPONENT_PROFILES;
      this.autoDetectionRules = AUTO_DETECTION_RULES;
      this.tagCompatibilityRules = TAG_COMPATIBILITY_RULES;
      this.initialized = true;
    }
  }

  /**
   * Load component profiles from database
   */
  private async loadProfilesFromDatabase(): Promise<void> {
    const { data, error } = await supabase
      .from('component_profiles')
      .select('*')
      .eq('is_active', true)
      .order('priority', { ascending: false });

    if (error) {
      throw new Error(`Failed to load component profiles: ${error.message}`);
    }

    this.profiles =
      data?.map(row => ({
        id: row.id,
        name: row.name,
        displayName: row.display_name,
        description: row.description || '',
        tags: row.tags as SemanticTag[],
        requiredSpecifications: row.required_specifications as StandardSpecification[],
        optionalSpecifications: row.optional_specifications as StandardSpecification[],
        categoryPatterns: row.category_patterns,
        priority: row.priority,
      })) || [];
  }

  /**
   * Load auto-detection rules from database
   */
  private async loadAutoDetectionRules(): Promise<void> {
    const { data, error } = await supabase
      .from('auto_detection_rules')
      .select('*')
      .eq('is_active', true)
      .order('confidence', { ascending: false });

    if (error) {
      throw new Error(`Failed to load auto-detection rules: ${error.message}`);
    }

    this.autoDetectionRules =
      data?.map(row => ({
        id: row.id,
        profileId: row.profile_id,
        patterns: row.patterns,
        keywords: row.keywords,
        excludePatterns: row.exclude_patterns || [],
        confidence: parseFloat(row.confidence),
      })) || [];
  }

  /**
   * Load tag compatibility rules from database
   */
  private async loadTagCompatibilityRules(): Promise<void> {
    const { data, error } = await supabase
      .from('tag_compatibility_rules')
      .select('*')
      .eq('is_active', true);

    if (error) {
      throw new Error(`Failed to load tag compatibility rules: ${error.message}`);
    }

    this.tagCompatibilityRules =
      data?.map(row => ({
        id: row.id,
        name: row.name,
        description: row.description || '',
        requiredTag: row.required_tag as SemanticTag,
        compatibleTags: row.compatible_tags as SemanticTag[],
        specificationKey: row.specification_key,
        severity: row.severity as 'error' | 'warning' | 'info',
      })) || [];
  }

  /**
   * Detect suitable component profiles for a category
   */
  public async detectProfilesForCategory(
    categoryName: string,
    categoryDescription?: string
  ): Promise<SpecificationDetectionResult> {
    await this.initialize();

    const categoryText = `${categoryName} ${categoryDescription || ''}`.toLowerCase();
    const suggestedProfiles: SpecificationDetectionResult['suggestedProfiles'] = [];
    const recommendedTags: SemanticTag[] = [];
    const autoGeneratedSpecs: StandardSpecification[] = [];

    // Check each auto-detection rule
    for (const rule of this.autoDetectionRules) {
      const profile = this.profiles.find(p => p.id === rule.profileId);
      if (!profile) continue;

      const matchedPatterns: string[] = [];
      const matchedKeywords: string[] = [];
      let isMatch = false;

      // Check patterns
      for (const pattern of rule.patterns) {
        try {
          const regex = new RegExp(pattern, 'i');
          if (regex.test(categoryText)) {
            matchedPatterns.push(pattern);
            isMatch = true;
          }
        } catch (error) {
          console.warn(`Invalid regex pattern: ${pattern}`, error);
        }
      }

      // Check keywords if no pattern matched
      if (!isMatch) {
        for (const keyword of rule.keywords) {
          if (categoryText.includes(keyword.toLowerCase())) {
            matchedKeywords.push(keyword);
            isMatch = true;
          }
        }
      }

      // Check exclude patterns
      if (isMatch && rule.excludePatterns) {
        for (const excludePattern of rule.excludePatterns) {
          try {
            const regex = new RegExp(excludePattern, 'i');
            if (regex.test(categoryText)) {
              isMatch = false;
              break;
            }
          } catch (error) {
            console.warn(`Invalid exclude regex pattern: ${excludePattern}`, error);
          }
        }
      }

      if (isMatch) {
        suggestedProfiles.push({
          profile,
          confidence: rule.confidence,
          matchedPatterns,
          matchedKeywords,
        });

        // Add profile tags to recommended tags
        profile.tags.forEach(tag => {
          if (!recommendedTags.includes(tag)) {
            recommendedTags.push(tag);
          }
        });

        // Add profile specifications to auto-generated specs
        [...profile.requiredSpecifications, ...profile.optionalSpecifications].forEach(spec => {
          if (!autoGeneratedSpecs.find(s => s.name === spec.name)) {
            autoGeneratedSpecs.push(spec);
          }
        });
      }
    }

    // Sort by confidence
    suggestedProfiles.sort((a, b) => b.confidence - a.confidence);

    return {
      suggestedProfiles,
      recommendedTags,
      autoGeneratedSpecs: autoGeneratedSpecs.sort((a, b) => a.displayOrder - b.displayOrder),
    };
  }

  /**
   * Apply a profile to a category
   */
  public async applyProfileToCategory(
    categoryId: string,
    profileId: string,
    customTags?: SemanticTag[]
  ): Promise<void> {
    await this.initialize();

    const profile = this.profiles.find(p => p.id === profileId);
    if (!profile) {
      throw new Error(`Profile not found: ${profileId}`);
    }

    const tags = customTags || profile.tags;
    const autoGeneratedSpecs = [
      ...profile.requiredSpecifications,
      ...profile.optionalSpecifications,
    ];

    const { error } = await supabase
      .from('categories')
      .update({
        specification_tags: tags,
        suggested_profiles: [profileId],
        auto_generated_specs: autoGeneratedSpecs,
        smart_detection_enabled: true,
        last_profile_detection: new Date().toISOString(),
      })
      .eq('id', categoryId);

    if (error) {
      throw new Error(`Failed to apply profile to category: ${error.message}`);
    }
  }

  /**
   * Get specifications for a category based on its semantic tags
   */
  public async getSpecificationsForCategory(categoryId: string): Promise<{
    autoGenerated: StandardSpecification[];
    custom: StandardSpecification[];
    all: StandardSpecification[];
  }> {
    const { data, error } = await supabase
      .from('categories')
      .select('auto_generated_specs, custom_specs')
      .eq('id', categoryId)
      .single();

    if (error) {
      throw new Error(`Failed to get category specifications: ${error.message}`);
    }

    const autoGenerated = (data?.auto_generated_specs as StandardSpecification[]) || [];
    const custom = (data?.custom_specs as StandardSpecification[]) || [];
    const all = [...autoGenerated, ...custom].sort((a, b) => a.displayOrder - b.displayOrder);

    return { autoGenerated, custom, all };
  }

  /**
   * Add custom specification to a category
   */
  public async addCustomSpecification(
    categoryId: string,
    specification: Omit<StandardSpecification, 'displayOrder'>
  ): Promise<void> {
    const { data: category, error: fetchError } = await supabase
      .from('categories')
      .select('custom_specs, auto_generated_specs')
      .eq('id', categoryId)
      .single();

    if (fetchError) {
      throw new Error(`Failed to fetch category: ${fetchError.message}`);
    }

    const customSpecs = (category?.custom_specs as StandardSpecification[]) || [];
    const autoSpecs = (category?.auto_generated_specs as StandardSpecification[]) || [];

    // Calculate display order
    const maxOrder = Math.max(
      ...autoSpecs.map(s => s.displayOrder),
      ...customSpecs.map(s => s.displayOrder),
      0
    );

    const newSpec: StandardSpecification = {
      ...specification,
      displayOrder: maxOrder + 10,
    };

    const updatedCustomSpecs = [...customSpecs, newSpec];

    const { error } = await supabase
      .from('categories')
      .update({ custom_specs: updatedCustomSpecs })
      .eq('id', categoryId);

    if (error) {
      throw new Error(`Failed to add custom specification: ${error.message}`);
    }
  }

  /**
   * Validate a specification value using the smart system
   */
  public validateSpecification(
    value: unknown,
    specification: StandardSpecification,
    context?: Record<string, unknown>
  ): SpecificationValidationResult {
    // Create a default validation rule if none exists
    let validationRule = specification.validationRule;

    if (!validationRule) {
      validationRule = {
        required: specification.isRequired || false,
        dataType: specification.dataType,
        compatibilityKey: specification.isCompatibilityKey || false,
      };
    }

    return SpecificationValidator.validateAndNormalize(value, validationRule, context);
  }

  /**
   * Check compatibility between components using semantic tags
   */
  public async checkTagCompatibility(
    components: Array<{
      tags: SemanticTag[];
      specifications: Record<string, unknown>;
    }>
  ): Promise<{
    isCompatible: boolean;
    issues: Array<{
      rule: TagCompatibilityRule;
      message: string;
      severity: 'error' | 'warning' | 'info';
    }>;
  }> {
    await this.initialize();

    const issues: Array<{
      rule: TagCompatibilityRule;
      message: string;
      severity: 'error' | 'warning' | 'info';
    }> = [];

    // Check each compatibility rule
    for (const rule of this.tagCompatibilityRules) {
      // Skip power consumption compatibility rule if conditions are not met
      if (rule.id === 'power-consumption-compatibility') {
        // Only check power supply compatibility if:
        // 1. There's a GPU with recommended_psu_power, OR
        // 2. There are at least 3 components including CPU and GPU
        const hasGpuWithPowerReq = components.some(c => 
          (c.tags.includes(SemanticTag.HAS_GRAPHICS) || c.tags.includes(SemanticTag.GRAPHICS_ACCELERATED)) && 
          c.specifications['recommended_psu_power']
        );
        
        const hasCpu = components.some(c => c.tags.includes(SemanticTag.PROCESSING_UNIT));
        const hasGpu = components.some(c => 
          c.tags.includes(SemanticTag.HAS_GRAPHICS) || c.tags.includes(SemanticTag.GRAPHICS_ACCELERATED)
        );
        const hasMinimalBuild = components.length >= 3 && hasCpu && hasGpu;
        
        if (!hasGpuWithPowerReq && !hasMinimalBuild) {
          continue; // Skip power supply validation
        }
      }

      const componentsWithRequiredTag = components.filter(c => c.tags.includes(rule.requiredTag));

      if (componentsWithRequiredTag.length === 0) continue;

      const componentsWithCompatibleTags = components.filter(c =>
        rule.compatibleTags.some(tag => c.tags.includes(tag))
      );

      if (componentsWithCompatibleTags.length === 0) {
        issues.push({
          rule,
          message: `${rule.name}: ${rule.description}`,
          severity: rule.severity,
        });
        continue;
      }

      // Check specification compatibility if specified
      if (rule.specificationKey) {
        for (const requiredComponent of componentsWithRequiredTag) {
          const requiredValue = requiredComponent.specifications[rule.specificationKey];
          if (!requiredValue) continue;

          let isSpecCompatible = false;
          for (const compatibleComponent of componentsWithCompatibleTags) {
            const compatibleValue = compatibleComponent.specifications[rule.specificationKey];
            if (
              compatibleValue &&
              this.areSpecificationsCompatible(
                requiredValue,
                compatibleValue,
                rule.specificationKey
              )
            ) {
              isSpecCompatible = true;
              break;
            }
          }

          if (!isSpecCompatible) {
            issues.push({
              rule,
              message: `${rule.name}: Incompatible ${rule.specificationKey} values`,
              severity: rule.severity,
            });
          }
        }
      }
    }

    const hasErrors = issues.some(issue => issue.severity === 'error');
    return {
      isCompatible: !hasErrors,
      issues,
    };
  }

  /**
   * Check if two specification values are compatible
   */
  private areSpecificationsCompatible(
    value1: unknown,
    value2: unknown,
    specificationKey: string
  ): boolean {
    // For socket compatibility, values must match exactly
    if (specificationKey === 'socket') {
      return value1 === value2;
    }

    // For power consumption, PSU wattage must be >= total consumption
    if (specificationKey === 'power_consumption' || specificationKey === 'wattage') {
      const consumption = typeof value1 === 'number' ? value1 : parseFloat(value1);
      const supply = typeof value2 === 'number' ? value2 : parseFloat(value2);
      return supply >= consumption * 1.2; // 20% headroom
    }

    // For memory type, values must match
    if (specificationKey === 'memory_type') {
      return value1 === value2;
    }

    // For form factor, values must match
    if (specificationKey === 'form_factor') {
      return value1 === value2;
    }

    // For memory slots, available slots must be >= required slots
    if (specificationKey === 'memory_slots') {
      const required = typeof value1 === 'number' ? value1 : parseFloat(value1);
      const available = typeof value2 === 'number' ? value2 : parseFloat(value2);
      return available >= required;
    }

    // Default: values must match
    return value1 === value2;
  }

  /**
   * Get all available semantic tags
   */
  public getAvailableSemanticTags(): Array<{
    tag: SemanticTag;
    displayName: string;
    description: string;
    category: string;
  }> {
    return [
      // Power-related tags
      {
        tag: SemanticTag.POWER_CONSUMER,
        displayName: 'Power Consumer',
        description: 'Component consumes power',
        category: 'Power',
      },
      {
        tag: SemanticTag.POWER_PROVIDER,
        displayName: 'Power Provider',
        description: 'Component provides power (PSU)',
        category: 'Power',
      },
      {
        tag: SemanticTag.POWER_EFFICIENT,
        displayName: 'Power Efficient',
        description: 'Low power consumption component',
        category: 'Power',
      },

      // Socket and connectivity tags
      {
        tag: SemanticTag.REQUIRES_SOCKET,
        displayName: 'Requires Socket',
        description: 'Needs a socket (CPU)',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.HAS_SOCKET,
        displayName: 'Has Socket',
        description: 'Provides socket (Motherboard)',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.REQUIRES_SLOT,
        displayName: 'Requires Slot',
        description: 'Needs expansion slot (GPU, RAM)',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.HAS_SLOTS,
        displayName: 'Has Slots',
        description: 'Provides slots (Motherboard)',
        category: 'Connectivity',
      },

      // Graphics and display tags
      {
        tag: SemanticTag.HAS_GRAPHICS,
        displayName: 'Has Graphics',
        description: 'Has graphics capability',
        category: 'Graphics',
      },
      {
        tag: SemanticTag.REQUIRES_GRAPHICS,
        displayName: 'Requires Graphics',
        description: 'Needs graphics (Monitor)',
        category: 'Graphics',
      },
      {
        tag: SemanticTag.GRAPHICS_ACCELERATED,
        displayName: 'Graphics Accelerated',
        description: 'High-performance graphics',
        category: 'Graphics',
      },

      // Thermal management tags
      {
        tag: SemanticTag.GENERATES_HEAT,
        displayName: 'Generates Heat',
        description: 'Produces heat (CPU, GPU)',
        category: 'Thermal',
      },
      {
        tag: SemanticTag.PROVIDES_COOLING,
        displayName: 'Provides Cooling',
        description: 'Provides cooling (Cooler, Fan)',
        category: 'Thermal',
      },
      {
        tag: SemanticTag.REQUIRES_COOLING,
        displayName: 'Requires Cooling',
        description: 'Needs cooling',
        category: 'Thermal',
      },

      // Memory and storage tags
      {
        tag: SemanticTag.HAS_MEMORY,
        displayName: 'Has Memory',
        description: 'Has memory (RAM, Storage)',
        category: 'Memory',
      },
      {
        tag: SemanticTag.REQUIRES_MEMORY,
        displayName: 'Requires Memory',
        description: 'Needs memory',
        category: 'Memory',
      },
      {
        tag: SemanticTag.VOLATILE_MEMORY,
        displayName: 'Volatile Memory',
        description: 'RAM-type memory',
        category: 'Memory',
      },
      {
        tag: SemanticTag.PERSISTENT_STORAGE,
        displayName: 'Persistent Storage',
        description: 'Storage devices',
        category: 'Memory',
      },

      // Form factor and physical tags
      {
        tag: SemanticTag.HAS_FORM_FACTOR,
        displayName: 'Has Form Factor',
        description: 'Has specific form factor',
        category: 'Physical',
      },
      {
        tag: SemanticTag.REQUIRES_FORM_FACTOR,
        displayName: 'Requires Form Factor',
        description: 'Needs specific form factor',
        category: 'Physical',
      },
      {
        tag: SemanticTag.MODULAR,
        displayName: 'Modular',
        description: 'Modular component',
        category: 'Physical',
      },

      // Connectivity tags
      {
        tag: SemanticTag.HAS_PORTS,
        displayName: 'Has Ports',
        description: 'Provides ports/connectors',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.REQUIRES_PORTS,
        displayName: 'Requires Ports',
        description: 'Needs specific ports',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.WIRELESS_CAPABLE,
        displayName: 'Wireless Capable',
        description: 'Has wireless connectivity',
        category: 'Connectivity',
      },
      {
        tag: SemanticTag.WIRED_ONLY,
        displayName: 'Wired Only',
        description: 'Only wired connectivity',
        category: 'Connectivity',
      },

      // Performance tags
      {
        tag: SemanticTag.HIGH_PERFORMANCE,
        displayName: 'High Performance',
        description: 'High-end component',
        category: 'Performance',
      },
      {
        tag: SemanticTag.BUDGET_FRIENDLY,
        displayName: 'Budget Friendly',
        description: 'Budget component',
        category: 'Performance',
      },
      {
        tag: SemanticTag.OVERCLOCKABLE,
        displayName: 'Overclockable',
        description: 'Can be overclocked',
        category: 'Performance',
      },

      // Special function tags
      {
        tag: SemanticTag.RGB_LIGHTING,
        displayName: 'RGB Lighting',
        description: 'Has RGB lighting',
        category: 'Special',
      },
      {
        tag: SemanticTag.SILENT_OPERATION,
        displayName: 'Silent Operation',
        description: 'Quiet operation',
        category: 'Special',
      },
      {
        tag: SemanticTag.WATER_COOLING,
        displayName: 'Water Cooling',
        description: 'Water cooling related',
        category: 'Special',
      },
      {
        tag: SemanticTag.AIR_COOLING,
        displayName: 'Air Cooling',
        description: 'Air cooling related',
        category: 'Special',
      },
    ];
  }

  /**
   * Get all available component profiles
   */
  public async getAvailableProfiles(): Promise<ComponentProfile[]> {
    await this.initialize();
    return this.profiles;
  }

  /**
   * Get a specific profile by ID
   */
  public async getProfile(profileId: string): Promise<ComponentProfile | null> {
    await this.initialize();
    return this.profiles.find(p => p.id === profileId) || null;
  }
}
